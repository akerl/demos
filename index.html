<style>
.emscripten {
    padding-right: 0;
    margin-left: auto;
    margin-right: auto;
    display: block;
}
canvas.emscripten {
    border: 0px none;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    width: 482px;
    height: 324px;
}
</style>
<canvas class="emscripten" id="canvas"></canvas>
<script type='text/javascript'>
var romData = null;
var vbamReady = false;

var
	REQ_GIMME_SINCE = 0,
	REQ_SET_VOTE = 1,
	REQ_SET_RUNNING = 2,
	RES_HERES_YOUR_STUFF = 0,
	RES_BATCH = 1;

function benchmark() {
    var a = new Date().getTime();
    for (var i = 0; i < 1200; i++) {
        vbam_js_main();
    }
    var b = new Date().getTime();
    alert(b - a);
}

function someError(msg) {
    alert(msg);
    throw 'ack...';
}

var pendingInputs = [];

function emulationTick() {
    var doneThisFrame = 0;
    while(pendingInputs.length > 30 && doneThisFrame++ < 2) {
        currentInput = pendingInputs.shift();
        vbam_js_main();
        currentFrame++;
    }
    drawFrame();
    requestAnimationFrame(emulationTick);
    //setTimeout(emulationTick, 1000);
}

currentVote = 0;

function keyCodeToMask(code) {
    switch(code) {
    case 13: // DOM_VK_RETURN
        return 8; // start
    case 90: // DOM_VK_Z
        return 1; // A
    case 88: // DOM_VK_X
        return 2; // B
    case 87: // DOM_VK_W
    case 38: // DOM_VK_UP
        return 64; // up
    case 65: // DOM_VK_A
    case 37: // DOM_VK_LEFT
        return 32; // left
    case 83: // DOM_VK_S
    case 40: // DOM_VK_DOWN
        return 128; // down
    case 68: // DOM_VK_D
    case 39: // DOM_VK_RIGHT
        return 16; // right
    case 73: // DOM_VK_I
        return 512; // L
    case 79: // DOM_VK_O
        return 256; // R
    case 80: // DOM_VK_P
        return 4; // select
    }
    return 0;
}

function updateVote(vote) {
    currentVote = vote;
    var data = new DataView(new ArrayBuffer(3));
    data.setUint8(0, REQ_SET_VOTE);
    data.setUint16(1, vote, true);
    ws.send(data.buffer);
}

function startEmulation() {
    window.onkeydown = function(e) {
        var mask = keyCodeToMask(e.keyCode);
        if(mask) {
            updateVote(currentVote | mask);
            return false;
        }
    };
    window.onkeyup = function(e) {
        var mask = keyCodeToMask(e.keyCode);
        if(mask) {
            updateVote(currentVote & ~mask);
            return false;
        }
    }
    emulationTick();
}

function connectToSocket() {
    ws = new WebSocket('ws://' + location.hostname + ':4321/keyserver', 'keyserver');
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        console.log('WS open');
		var data = new DataView(new ArrayBuffer(9));
		data.setUint8(0, REQ_GIMME_SINCE);
		data.setUint32(1, currentFrame, true);
		data.setUint32(5, currentFrame / 0x100000000, true);
		ws.send(data.buffer);
    }
    ws.onmessage = function(e) {
        var msg = new Uint8Array(e.data);
		var dv = new DataView(msg.buffer);
		if(msg[0] == RES_HERES_YOUR_STUFF) {
			console.log('startup got ' + (msg.length - 1)/2 + ' frames');
			for(var i = 1; i < msg.length; i += 2)
                pendingInputs.push(dv.getUint16(i, true));
            startEmulation();
		} else if(msg[0] == RES_BATCH) {
			var offset = 1;
			var frame = dv.getUint32(offset, true) + dv.getUint32(offset + 4, true) * 0x100000000;
			offset += 8;
			var numPlayers = dv.getUint32(offset, true); offset += 4;
			var numInputs = msg[offset++];
			for(var i = 0; i < numInputs; i++) {
				if(frame >= currentFrame)
					pendingInputs.push(dv.getUint16(offset, true));
				offset += 2;
				frame++;
			}
			// ignore popularity data
		}
    }
    ws.onerror = function(e) {
        someError('WebSocket error');
    }
}

function loadSave() {
    loadURL('saves/current.sgm', function(state) {
        var buf = Module._malloc(state.byteLength);
        Module.HEAPU8.set(new Uint8Array(state), buf);
        var length = state.byteLength - 12;
        console.log(length);
        var i = (buf + length)/4;
        var id = Module.HEAPU32[i];
        var frameLo = Module.HEAPU32[i+1];
        var frameHi = Module.HEAPU32[i+2];
        if(id != 0xfeedfeed)
            someError('Invalid state file');
        currentFrame = frameLo + (frameHi * 0x100000000);
        if(!vbam_js_load_state(buf, length))
            someError('Load state failed');
        Module._free(buf);
        connectToSocket();
    }, function() { someError("Couldn't load state"); });
}

function loadingPhase1() {
    if(romData && vbamReady) {
        vbam_js_init('rom.gba');
        loadSave();
    }
}

function loadURL(url, callback, error) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'arraybuffer';

    xhr.onload = function() { callback(xhr.response) };
    xhr.onerror = error;
    xhr.send();
}

loadURL('rom.gba', function(buf) {
    romData = buf;
    loadingPhase1();
}, function() { someError("Couldn't load ROM"); });

function vsysReadJoypad(which) {
    return currentInput;
}

function vsysGetExternalFile(file, resultPtr, sizePtr) {
    var fn = Module.Pointer_stringify(file);
    console.log(fn);
    var size = romData.byteLength;
    var buf = Module.HEAPU32[resultPtr/4] || Module._malloc(size);
    Module.HEAPU8.set(new Uint8Array(romData), buf);
    Module.HEAPU32[resultPtr/4] = buf;
    Module.HEAPU32[sizePtr/4] = size;
}


function vsysInitSound() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    try {
        audioContext = new AudioContext();
    } catch(e) {
        throw 'no audio API support';
    }

    heapS16 = new Int16Array(Module.HEAPU16.buffer);

    return audioContext.sampleRate;
}

soundNextTime = 0;

function vsysWriteSound(buf, length) {
    var samples = length >> 2;
    var source = audioContext.createBufferSource();
    // waste of time
    var buffer = audioContext.createBuffer(2, samples, audioContext.sampleRate);
    var l = buffer.getChannelData(0);
    var r = buffer.getChannelData(1);
    //console.log(length, h16[buf], h16[buf+1], h16[buf+2], h16[buf+3]);
    var h16 = heapS16;
    for(var i = 0, p = buf/2; i < samples; i++, p += 2) {
        l[i] = h16[p] / 0x8000;
        r[i] = h16[p + 1] / 0x8000;
    }
    source.buffer = buffer;
    source.onended = function() {
        source.disconnect();
    }
    source.connect(audioContext.destination);
    var time = soundNextTime;
    if(time < audioContext.currentTime - 0.1 ||
       time > audioContext.currentTime + 1) {
        console.log('Resetting...' + (time - audioContext.currentTime));
        time = audioContext.currentTime + 0.2;
    }
    source.start(time);
    soundNextTime = time + samples / audioContext.sampleRate;
}

function vsysInitGraphics(width, height, pix) {
    cvs = document.getElementById('canvas');
    cvs.width = width;
    cvs.height = height;
    c2d = cvs.getContext('2d');
    imageData = c2d.createImageData(width, height);
    imagePix = new Uint8Array(Module.HEAPU8.buffer, pix, 4*width*height);
}

function drawFrame() {
    //console.log(imagePix[0], imagePix[1], imagePix[2], imagePix[3]);
    imageData.data.set(imagePix);
    c2d.putImageData(imageData, 0, 0);
}

function ready() {
    vbam_js_init = Module.cwrap('vbam_js_init', 'void', ['string']);
    vbam_js_main = Module.cwrap('vbam_js_main', 'void', []);
    vbam_js_save_state = Module.cwrap('vbam_js_save_state', 'number', ['number', 'number']);
    vbam_js_load_state = Module.cwrap('vbam_js_load_state', 'number', ['number', 'number']);
    vbamReady = true;
    loadingPhase1();
}

var Module = {
    preRun: [],
    postRun: [ready],
    print: function(text) {
        console.log(text);
    },
    printErr: function(text) {
        console.log(text);
    },
    setStatus: function(text) {
        console.log(text);
    },
    TOTAL_MEMORY: 64*1024*1024,
};
</script>
<script async type="text/javascript" src="vbam.js"></script>
